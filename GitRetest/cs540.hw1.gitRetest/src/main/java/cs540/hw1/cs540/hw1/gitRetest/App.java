package cs540.hw1.cs540.hw1.gitRetest;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;

import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.api.errors.NoHeadException;
import org.eclipse.jgit.diff.DiffEntry;
import org.eclipse.jgit.lib.ObjectReader;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.revwalk.RevCommit;
import org.eclipse.jgit.revwalk.RevTree;
import org.eclipse.jgit.revwalk.RevWalk;
import org.eclipse.jgit.storage.file.FileRepositoryBuilder;
import org.eclipse.jgit.treewalk.AbstractTreeIterator;
import org.eclipse.jgit.treewalk.CanonicalTreeParser;

public class App {

	private static String INPUT_CLONE_DIR = "./Testing_output/tdd-tetris-tutorial/";

	private static String OUTPUT_RETEST_FILES = "./src/main/resources/output_retest_data.txt";
	
	private static String OUTPUT_CSV_DEPENDENCY="./src/main/resources/Tetris_FileDependencies.csv";

	public static void main(String[] args) throws NoHeadException, IOException, GitAPIException {

		if (args.length > 0) {
			INPUT_CLONE_DIR = args[0];
			OUTPUT_RETEST_FILES = args[1];
			OUTPUT_CSV_DEPENDENCY=args[2];
		}

		String listOfFiles = getChangedFiles(getLastCommit(INPUT_CLONE_DIR), INPUT_CLONE_DIR);

		String dependenciesList=getRetestFileList(listOfFiles,OUTPUT_CSV_DEPENDENCY);
		Utility.writeMyFile(OUTPUT_RETEST_FILES, dependenciesList);
		//Utility.writeMyFile(OUTPUT_RETEST_FILES, listOfFiles);
	}

	private static Repository openJGitCookbookRepository(String location) throws IOException {
		FileRepositoryBuilder builder = new FileRepositoryBuilder();
		return builder.readEnvironment() // scan environment GIT_* variables
				.findGitDir(new File(location)) // scan up the file system tree
				.build();
	}

	private static String getLastCommit(String location) throws IOException, NoHeadException, GitAPIException {
		try {
			Repository repository = openJGitCookbookRepository(location);
			String entireCommit = "";
			
				Git git = new Git(repository);
				Iterable<RevCommit> commits = git.log().all().call();
				for (RevCommit commit : commits) {
					entireCommit = commit.name();
					System.out.println("LogCommit: " + commit.name());
					break;
				}
				return entireCommit;
			
			
		} finally {

		}
		
	}

	private static String getChangedFiles(String commitId, String location) throws IOException, GitAPIException {
		try {
			Repository repository = openJGitCookbookRepository(location);
			try {
				Git git = new Git(repository);
				// to compare against the "previous" commit, you can use
				// the caret-notation

				return listDiff(repository, git, commitId + "^", commitId);

			} finally {

			}
		} finally {

		}
	}

	private static String listDiff(Repository repository, Git git, String oldCommit, String newCommit)
			throws GitAPIException, IOException {
		final List<DiffEntry> diffs = git.diff().setOldTree(prepareTreeParser(repository, oldCommit))
				.setNewTree(prepareTreeParser(repository, newCommit)).call();

		System.out.println("Found: " + diffs.size() + " differences");
		StringBuffer filesList = new StringBuffer();
		for (DiffEntry diff : diffs) {
			System.out.println(
					"Diff: " + (diff.getOldPath().equals(diff.getNewPath()) ? diff.getNewPath() : diff.getOldPath()));
			filesList.append(
					(diff.getOldPath().equals(diff.getNewPath()) ? diff.getNewPath() : diff.getOldPath()) + "\n");
		}

		return filesList.toString();
	}

	private static AbstractTreeIterator prepareTreeParser(Repository repository, String objectId) throws IOException {
		// from the commit we can build the tree which allows us to construct the
		// TreeParser
		// noinspection Duplicates
		try {
			RevWalk walk = new RevWalk(repository);
			RevCommit commit = walk.parseCommit(repository.resolve(objectId));
			RevTree tree = walk.parseTree(commit.getTree().getId());

			CanonicalTreeParser treeParser = new CanonicalTreeParser();
			ObjectReader reader = repository.newObjectReader(); 
				treeParser.reset(reader, tree.getId());
			

			walk.dispose();

			return treeParser;
		} finally {

		}
	}
	
	/*
	 * Created by Chinmay G: 11-Mar-2018; Updated by Chinmay G: 14-Mar-2018
	 * 
	 * Provides list of files to be retested based on list of files with changes (files with latest commit)
	 * Input: 
	 * 	- Line-separated relative paths of files with changes
	 * 	- Path of csv file generated by Understand with dependencies ("From" in 1st column, "To" in 2nd column)
	 * 
	 * Output: Line-separated relative paths of files to be retested
	 */
	private static String getRetestFileList(String changedFiles, String csvDepPath) throws IOException
	{
		//Using set to avoid duplicates
		HashSet<String> depends = new HashSet<String>();
		String line = "", retestFiles = "";
		
		//List<String> changedFileList = Arrays.asList(changedFiles.replace("/", "\\").split("\\n"));
		List<String> changedFileList = Arrays.asList(changedFiles.split("\\n"));
		
		//Add changed files to list of files to be retested 
		for(String str: changedFileList)
			retestFiles+=str+"\n";
		
		BufferedReader br = null;       
        try
        {
            br = new BufferedReader(new FileReader(csvDepPath));
            while ((line = br.readLine()) != null)
            {
                String[] deps = line.split(",");
                
                //Remove project folder name from path in csv entry
                //deps[1] = deps[1].replace(deps[1].split("\\\\")[0],"");
                deps[1] = deps[1].replace(deps[1].split("/")[0],"");
				if(!deps[1].isEmpty())
                	deps[1] = deps[1].substring(1);

                if(changedFileList.contains(deps[1]))
                {
                	//deps[0] = deps[0].replace(deps[0].split("\\\\")[0],"").substring(1);
                	deps[0] = deps[0].replace(deps[0].split("/")[0],"").substring(1);
                	
                	if(!changedFileList.contains(deps[0]))
                		depends.add(deps[0]);
                }
            }
        } finally {
            if (br != null)
            {
                br.close(); 
            }
        }
        
        //convert Set to String of filenames: one per line
        for(String str: depends)
        	retestFiles+=str+"\n";
        
		return retestFiles;
	}

}
